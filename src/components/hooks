import { useState, useEffect } from 'react';
import { useWeb3 } from '../context/Web3Context';
import { contractService } from '../services/contractService';

export const useContract = (contractName) => {
  const { provider, signer, account } = useWeb3();
  const [contract, setContract] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const initContract = async () => {
      if (!provider || !account) {
        setContract(null);
        setLoading(false);
        return;
      }

      try {
        const contractInstance = await contractService.getContract(contractName, signer || provider);
        setContract(contractInstance);
      } catch (error) {
        console.error(`Error initializing ${contractName} contract:`, error);
        setContract(null);
      } finally {
        setLoading(false);
      }
    };

    initContract();
  }, [provider, signer, account, contractName]);

  return { contract, loading };
};

export const useBills = () => {
  const [bills, setBills] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  const { contract } = useContract('BillPayment');
  const { account } = useWeb3();

  const fetchBills = async () => {
    if (!contract || !account) return;
    
    setLoading(true);
    setError(null);
    
    try {
      const billIds = await contract.getUserBills(account);
      const billsData = await Promise.all(
        billIds.map(async (billId) => {
          const bill = await contract.bills(billId);
          return {
            id: billId.toString(),
            name: bill.name,
            amount: parseFloat(bill.amount) / 1e6,
            recipient: bill.recipient,
            frequency: bill.frequency,
            nextDueDate: new Date(bill.nextDueDate.toNumber() * 1000),
            isActive: bill.isActive,
            paymentCount: bill.paymentCount.toNumber()
          };
        })
      );
      setBills(billsData);
    } catch (error) {
      console.error('Error fetching bills:', error);
      setError('Failed to load bills');
    } finally {
      setLoading(false);
    }
  };

  const createBill = async (billData) => {
    if (!contract) throw new Error('Contract not initialized');
    
    const amountInWei = Math.floor(billData.amount * 1e6);
    const dueDateTimestamp = Math.floor(new Date(billData.dueDate).getTime() / 1000);
    
    const tx = await contract.createBill(
      billData.name,
      amountInWei,
      billData.recipient,
      billData.frequency,
      dueDateTimestamp
    );
    
    await tx.wait();
    await fetchBills();
    return tx;
  };

  const payBill = async (billId, amount) => {
    if (!contract) throw new Error('Contract not initialized');
    
    const amountInWei = Math.floor(amount * 1e6);
    const tx = await contract.payBill(billId, amountInWei);
    await tx.wait();
    await fetchBills();
    return tx;
  };

  const toggleBillStatus = async (billId) => {
    if (!contract) throw new Error('Contract not initialized');
    
    const tx = await contract.toggleBillStatus(billId);
    await tx.wait();
    await fetchBills();
    return tx;
  };

  useEffect(() => {
    fetchBills();
  }, [contract, account]);

  return {
    bills,
    loading,
    error,
    createBill,
    payBill,
    toggleBillStatus,
    refetch: fetchBills
  };
};

export const useNFTRewards = () => {
  const [nfts, setNfts] = useState([]);
  const [stats, setStats] = useState({
    totalNFTs: 0,
    totalPayments: 0,
    currentStreak: 0,
    totalSaved: 0
  });
  const [loading, setLoading] = useState(true);
  const { contract } = useContract('NFTRewards');
  const { account } = useWeb3();

  const fetchNFTs = async () => {
    if (!contract || !account) return;
    
    setLoading(true);
    try {
      const balance = await contract.balanceOf(account);
      const nftData = [];
      
      for (let i = 0; i < balance; i++) {
        const tokenId = await contract.tokenOfOwnerByIndex(account, i);
        const tokenURI = await contract.tokenURI(tokenId);
        const nftInfo = await contract.nftInfo(tokenId);
        
        nftData.push({
          tokenId: tokenId.toString(),
          tier: nftInfo.tier,
          mintDate: new Date(nftInfo.mintDate.toNumber() * 1000),
          paymentsCount: nftInfo.paymentsCount.toNumber(),
          metadata: JSON.parse(atob(tokenURI.split(',')[1]))
        });
      }
      
      setNfts(nftData);
      
      const userStats = await contract.userStats(account);
      setStats({
        totalNFTs: balance.toNumber(),
        totalPayments: userStats.totalPayments.toNumber(),
        currentStreak: userStats.currentStreak.toNumber(),
        totalSaved: parseFloat(userStats.totalSaved) / 1e6
      });
    } catch (error) {
      console.error('Error fetching NFTs:', error);
    } finally {
      setLoading(false);
    }
  };

  const claimReward = async () => {
    if (!contract) throw new Error('Contract not initialized');
    
    const tx = await contract.claimReward();
    await tx.wait();
    await fetchNFTs();
    return tx;
  };

  useEffect(() => {
    fetchNFTs();
  }, [contract, account]);

  return {
    nfts,
    stats,
    loading,
    claimReward,
    refetch: fetchNFTs
  };
};

export const useBillPools = () => {
  const [pools, setPools] = useState([]);
  const [myPools, setMyPools] = useState([]);
  const [loading, setLoading] = useState(true);
  const { contract } = useContract('BillPool');
  const { account } = useWeb3();

  const fetchPools = async () => {
    if (!contract || !account) return;
    
    setLoading(true);
    try {
      const poolCount = await contract.poolCount();
      const allPools = [];
      const userPools = [];
      
      for (let i = 0; i < poolCount; i++) {
        const pool = await contract.pools(i);
        const members = await contract.getPoolMembers(i);
        
        const poolData = {
          id: i,
          name: pool.name,
          description: pool.description,
          targetAmount: parseFloat(pool.targetAmount) / 1e6,
          currentAmount: parseFloat(pool.currentAmount) / 1e6,
          creator: pool.creator,
          maxMembers: pool.maxMembers.toNumber(),
          dueDate: new Date(pool.dueDate.toNumber() * 1000),
          isActive: pool.isActive,
          isCompleted: pool.isCompleted,
          members: members,
          memberCount: members.length
        };
        
        allPools.push(poolData);
        
        if (members.includes(account)) {
          userPools.push(poolData);
        }
      }
      
      setPools(allPools);
      setMyPools(userPools);
    } catch (error) {
      console.error('Error fetching pools:', error);
    } finally {
      setLoading(false);
    }
  };

  const createPool = async (poolData) => {
    if (!contract) throw new Error('Contract not initialized');
    
    const targetAmountInWei = Math.floor(poolData.targetAmount * 1e6);
    const dueDateTimestamp = Math.floor(new Date(poolData.dueDate).getTime() / 1000);
    
    const tx = await contract.createPool(
      poolData.name,
      poolData.description,
      targetAmountInWei,
      poolData.maxMembers,
      dueDateTimestamp,
      poolData.recipient
    );
    
    await tx.wait();
    await fetchPools();
    return tx;
  };

  const joinPool = async (poolId, amount) => {
    if (!contract) throw new Error('Contract not initialized');
    
    const amountInWei = Math.floor(amount * 1e6);
    const tx = await contract.joinPool(poolId, amountInWei);
    await tx.wait();
    await fetchPools();
    return tx;
  };

  const executePayment = async (poolId) => {
    if (!contract) throw new Error('Contract not initialized');
    
    const tx = await contract.executePayment(poolId);
    await tx.wait();
    await fetchPools();
    return tx;
  };

  useEffect(() => {
    fetchPools();
  }, [contract, account]);

  return {
    pools,
    myPools,
    loading,
    createPool,
    joinPool,
    executePayment,
    refetch: fetchPools
  };
};