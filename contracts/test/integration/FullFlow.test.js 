const { expect } = require("chai");
const { ethers } = require("hardhat");
const { time } = require("@nomicfoundation/hardhat-network-helpers");

describe("FEEEZ Full Integration Tests", function () {
    let billPayment, nftRewards, billPool, mockUSDC;
    let owner, user1, user2, user3, payee;
    
    beforeEach(async function () {
        [owner, user1, user2, user3, payee] = await ethers.getSigners();
        
        const MockUSDC = await ethers.getContractFactory("MockUSDC");
        mockUSDC = await MockUSDC.deploy();
        await mockUSDC.deployed();
        
        const BillPayment = await ethers.getContractFactory("BillPayment");
        billPayment = await BillPayment.deploy(mockUSDC.address);
        await billPayment.deployed();
        
        const NFTRewards = await ethers.getContractFactory("NFTRewards");
        nftRewards = await NFTRewards.deploy(billPayment.address);
        await nftRewards.deployed();
        
        const BillPool = await ethers.getContractFactory("BillPool");
        billPool = await BillPool.deploy(mockUSDC.address);
        await billPool.deployed();
        
        await billPayment.setNFTRewardsContract(nftRewards.address);
        
        await mockUSDC.mint(user1.address, ethers.utils.parseUnits("10000", 6));
        await mockUSDC.mint(user2.address, ethers.utils.parseUnits("10000", 6));
        await mockUSDC.mint(user3.address, ethers.utils.parseUnits("10000", 6));
        
        await mockUSDC.connect(user1).approve(billPayment.address, ethers.utils.parseUnits("10000", 6));
        await mockUSDC.connect(user2).approve(billPayment.address, ethers.utils.parseUnits("10000", 6));
        await mockUSDC.connect(user3).approve(billPayment.address, ethers.utils.parseUnits("10000", 6));
        
        await mockUSDC.connect(user1).approve(billPool.address, ethers.utils.parseUnits("5000", 6));
        await mockUSDC.connect(user2).approve(billPool.address, ethers.utils.parseUnits("5000", 6));
        await mockUSDC.connect(user3).approve(billPool.address, ethers.utils.parseUnits("5000", 6));
    });
    
    describe("Complete User Journey - Individual Bills", function () {
        it("Should handle complete bill payment lifecycle with NFT rewards", async function () {
            const billAmount = ethers.utils.parseUnits("100", 6);
            const dueDate = (await time.latest()) + 86400 * 30; // 30 days
            
            const billId = await billPayment.connect(user1).createBill(
                payee.address,
                billAmount,
                dueDate,
                0, // No recurring
                0, // OneTime
                "Electricity Bill - January",
                false
            );
            
            await billPayment.connect(user1).payBill(1);
            
            await time.increase(86400 * 4); // 4 days later
            await billPayment.connect(payee).releaseEscrow(1);
            
            const bill = await billPayment.getBill(1);
            expect(bill.status).to.equal(1); // Paid
            
            const userPaymentCount = await billPayment.getUserPaymentCount(user1.address);
            expect(userPaymentCount).to.equal(1);
        });
        
        it("Should create multiple bills and earn NFT rewards", async function () {
            const bills = [
                { amount: ethers.utils.parseUnits("100", 6), description: "Electric Bill 1" },
                { amount: ethers.utils.parseUnits("150", 6), description: "Water Bill 1" },
                { amount: ethers.utils.parseUnits("80", 6), description: "Internet Bill 1" },
                { amount: ethers.utils.parseUnits("200", 6), description: "Gas Bill 1" },
                { amount: ethers.utils.parseUnits("120", 6), description: "Electric Bill 2" }
            ];
            
            for (let i = 0; i < bills.length; i++) {
                const dueDate = (await time.latest()) + 86400 * (7 * (i + 1));
                
                await billPayment.connect(user1).createBill(
                    payee.address,
                    bills[i].amount,
                    dueDate,
                    0,
                    0,
                    bills[i].description,
                    false
                );
                
                await billPayment.connect(user1).payBill(i + 1);
                
                await time.increase(86400 * 4);
                await billPayment.connect(payee).releaseEscrow(i + 1);
            }
            
            const userPaymentCount = await billPayment.getUserPaymentCount(user1.address);
            expect(userPaymentCount).to.equal(5);
            
            const isEligible = await nftRewards.isEligibleForReward(user1.address);
            expect(isEligible).to.equal(true);
            
            const tokenId = await nftRewards.claimReward(user1.address);
            expect(tokenId).to.be.gt(0);
            
            const userNFTs = await nftRewards.getUserNFTs(user1.address);
            expect(userNFTs.length).to.equal(1);
        });
        
        it("Should handle recurring bills with auto-pay", async function () {
            const billAmount = ethers.utils.parseUnits("50", 6);
            const dueDate = (await time.latest()) + 86400 * 7; // 7 days
            const recurringInterval = 86400 * 30; // Monthly
            
            await billPayment.connect(user1).createBill(
                payee.address,
                billAmount,
                dueDate,
                recurringInterval,
                1, // Recurring
                "Monthly Internet Bill",
                true // Auto-pay enabled
            );
            
            await billPayment.connect(user1).payBill(1);
            
            await time.increase(86400 * 35); // 35 days later
            
            const upcomingBills = await billPayment.getUpcomingBills(user1.address, 86400 * 7);
            expect(upcomingBills.length).to.be.gt(0);
            
            await billPayment.connect(user1).executeAutoPay(1);
            
            const billPayments = await billPayment.getBillPayments(1);
            expect(billPayments.length).to.equal(2);
        });
    });
    
    describe("Complete User Journey - Bill Pools", function () {
        it("Should handle shared bill payment through pool", async function () {
            const targetAmount = ethers.utils.parseUnits("300", 6);
            const deadline = (await time.latest()) + 86400 * 14; // 14 days
            
            await billPool.connect(user1).createPool(
                "Shared Apartment Rent - March",
                targetAmount,
                deadline,
                ethers.utils.parseUnits("50", 6),
                ethers.utils.parseUnits("150", 6)
            );
            
            await billPool.connect(user1).contributeToPool(1, ethers.utils.parseUnits("100", 6));
            await billPool.connect(user2).contributeToPool(1, ethers.utils.parseUnits("100", 6));
            await billPool.connect(user3).contributeToPool(1, ethers.utils.parseUnits("100", 6));
            
            const pool = await billPool.getPool(1);
            expect(pool.currentAmount).to.equal(targetAmount);
            expect(await billPool.isPoolFunded(1)).to.equal(true);
            
            const payeeInitialBalance = await mockUSDC.balanceOf(payee.address);
            await billPool.connect(user1).completePool(1, payee.address);
            
            const payeeFinalBalance = await mockUSDC.balanceOf(payee.address);
            expect(payeeFinalBalance.sub(payeeInitialBalance)).to.equal(targetAmount);
        });
        
        it("Should handle pool cancellation and refunds", async function () {
            const targetAmount = ethers.utils.parseUnits("600", 6);
            const deadline = (await time.latest()) + 86400 * 7;
            
            await billPool.connect(user1).createPool(
                "Failed Pool - Insufficient Contributions",
                targetAmount,
                deadline,
                ethers.utils.parseUnits("100", 6),
                ethers.utils.parseUnits("200", 6)
            );
            
            const user2InitialBalance = await mockUSDC.balanceOf(user2.address);
            const user3InitialBalance = await mockUSDC.balanceOf(user3.address);
            
            await billPool.connect(user2).contributeToPool(1, ethers.utils.parseUnits("150", 6));
            await billPool.connect(user3).contributeToPool(1, ethers.utils.parseUnits("200", 6));
            
            await billPool.connect(user1).cancelPool(1);
            
            const user2FinalBalance = await mockUSDC.balanceOf(user2.address);
            const user3FinalBalance = await mockUSDC.balanceOf(user3.address);
            
            expect(user2FinalBalance).to.equal(user2InitialBalance);
            expect(user3FinalBalance).to.equal(user3InitialBalance);
        });
    });
    
    describe("Cross-Contract Integration", function () {
        it("Should handle bill payments that qualify for multiple NFT tiers", async function () {
            const billAmounts = [
                ethers.utils.parseUnits("100", 6), // Bill 1-5: Bronze tier eligibility
                ethers.utils.parseUnits("120", 6),
                ethers.utils.parseUnits("80", 6),
                ethers.utils.parseUnits("150", 6),
                ethers.utils.parseUnits("200", 6),
                ethers.utils.parseUnits("90", 6),  // Bill 6-10: Silver tier eligibility
                ethers.utils.parseUnits("110", 6),
                ethers.utils.parseUnits("130", 6),
                ethers.utils.parseUnits("160", 6),
                ethers.utils.parseUnits("180", 6),
                ethers.utils.parseUnits("200", 6), // Bill 11-15: Gold tier eligibility
                ethers.utils.parseUnits("220", 6),
                ethers.utils.parseUnits("250", 6),
                ethers.utils.parseUnits("300", 6),
                ethers.utils.parseUnits("350", 6)
            ];
            
            for (let i = 0; i < billAmounts.length; i++) {
                const dueDate = (await time.latest()) + 86400 * 7;
                
                await billPayment.connect(user1).createBill(
                    payee.address,
                    billAmounts[i],
                    dueDate,
                    0,
                    0,
                    `Test Bill ${i + 1}`,
                    false
                );
                
                await billPayment.connect(user1).payBill(i + 1);
                await time.increase(86400 * 4);
                await billPayment.connect(payee).releaseEscrow(i + 1);
                
                const userStats = await billPayment.getUserPaymentStats(user1.address);
                
                if ((i + 1) === 5) {
                    const tokenId = await nftRewards.claimReward(user1.address);
                    const nftDetails = await nftRewards.getNFTDetails(tokenId);
                    expect(nftDetails.tier).to.equal(1); // Silver tier
                }
                
                if ((i + 1) === 10) {
                    await nftRewards.upgradeNFTTier(1);
                    const nftDetails = await nftRewards.getNFTDetails(1);
                    expect(nftDetails.tier).to.equal(2); // Gold tier
                }
            }
            
            const finalUserNFTs = await nftRewards.getUserNFTs(user1.address);
            expect(finalUserNFTs.length).to.be.gte(1);
        });
        
        it("Should handle complex scenario with bills, pools, and rewards", async function () {
            // User1 pays individual bills
            for (let i = 0; i < 3; i++) {
                const dueDate = (await time.latest()) + 86400 * 7;
                await billPayment.connect(user1).createBill(
                    payee.address,
                    ethers.utils.parseUnits("100", 6),
                    dueDate,
                    0, 0,
                    `Individual Bill ${i + 1}`,
                    false
                );
                await billPayment.connect(user1).payBill(i + 1);
                await time.increase(86400 * 4);
                await billPayment.connect(payee).releaseEscrow(i + 1);
            }
            
            // Users participate in shared pool
            await billPool.connect(user1).createPool(
                "Shared Utility Bill",
                ethers.utils.parseUnits("450", 6),
                (await time.latest()) + 86400 * 14,
                ethers.utils.parseUnits("100", 6),
                ethers.utils.parseUnits("200", 6)
            );
            
            await billPool.connect(user1).contributeToPool(1, ethers.utils.parseUnits("150", 6));
            await billPool.connect(user2).contributeToPool(1, ethers.utils.parseUnits("150", 6));
            await billPool.connect(user3).contributeToPool(1, ethers.utils.parseUnits("150", 6));
            
            await billPool.connect(user1).completePool(1, payee.address);
            
            // Users continue individual payments to reach NFT eligibility
            for (let i = 3; i < 6; i++) {
                const dueDate = (await time.latest()) + 86400 * 7;
                await billPayment.connect(user1).createBill(
                    payee.address,
                    ethers.utils.parseUnits("120", 6),
                    dueDate,
                    0, 0,
                    `Individual Bill ${i + 1}`,
                    false
                );
                await billPayment.connect(user1).payBill(i + 1);
                await time.increase(86400 * 4);
                await billPayment.connect(payee).releaseEscrow(i + 1);
            }
            
            const user1PaymentCount = await billPayment.getUserPaymentCount(user1.address);
            expect(user1PaymentCount).to.equal(6);
            
            const tokenId = await nftRewards.claimReward(user1.address);
            expect(tokenId).to.be.gt(0);
            
            const pool = await billPool.getPool(1);
            expect(pool.status).to.equal(1); // Completed
            
            const userNFTs = await nftRewards.getUserNFTs(user1.address);
            expect(userNFTs.length).to.equal(1);
        });
    });
    
    describe("Error Handling and Edge Cases", function () {
        it("Should handle insufficient balance scenarios", async function () {
            await mockUSDC.connect(user1).transfer(owner.address, ethers.utils.parseUnits("9000", 6));
            
            const dueDate = (await time.latest()) + 86400 * 7;
            await billPayment.connect(user1).createBill(
                payee.address,
                ethers.utils.parseUnits("2000", 6), // More than user1 has
                dueDate,
                0, 0,
                "Expensive Bill",
                false
            );
            
            await expect(billPayment.connect(user1).payBill(1))
                .to.be.revertedWith("ERC20: transfer amount exceeds balance");
        });
        
        it("Should handle deadline scenarios properly", async function () {
            const dueDate = (await time.latest()) + 86400; // 1 day
            await billPayment.connect(user1).createBill(
                payee.address,
                ethers.utils.parseUnits("100", 6),
                dueDate,
                0, 0,
                "Time-sensitive Bill",
                false
            );
            
            await time.increaseTo(dueDate + 86400 * 2); // 2 days past due
            
            await expect(billPayment.connect(user1).payBill(1))
                .to.be.revertedWith("Bill payment window expired");
        });
        
        it("Should handle contract pausing scenarios", async function () {
            await billPayment.pause();
            
            await expect(billPayment.connect(user1).createBill(
                payee.address,
                ethers.utils.parseUnits("100", 6),
                (await time.latest()) + 86400 * 7,
                0, 0,
                "Paused Contract Bill",
                false
            )).to.be.revertedWith("Pausable: paused");
            
            await billPayment.unpause();
            
            await expect(billPayment.connect(user1).createBill(
                payee.address,
                ethers.utils.parseUnits("100", 6),
                (await time.latest()) + 86400 * 7,
                0, 0,
                "Unpaused Contract Bill",
                false
            )).to.not.be.reverted;
        });
    });
});